<html>

<head>
	<title>Home</title>
	<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
</head>

<body class="bg-secondary">
	<header>
		<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
		  <a class="navbar-brand" href="./index.html">Kurem</a>
		  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
		    <span class="navbar-toggler-icon"></span>
		  </button>

		  <div class="collapse navbar-collapse" id="navbarSupportedContent">
		    <ul class="navbar-nav mr-auto">
		      <li class="nav-item" id="nav-item-home">
		        <a class="nav-link" href="./index.html">Home</a>
		      </li>
		      <li class="nav-item">
		        <a class="nav-link" href="./reference.html" id="nav-item-documentation">Reference</a>
		      </li>

					<li class="nav-item">
		        <a class="nav-link" href="./about.html" id="nav-item-about">About Us</a>
		      </li>
					<li class="nav-item">
		        <a class="nav-link" href="./instruction-set-song.html" id="nav-item-about">Instruction Set Song</a>
		      </li>
		    </ul>

		  </div>
		</nav>
	</header>
	<main>
		<div class="container bg-light" id="main-content">
			<p>The following tables were compiled from data included in the <a href=https://inst.eecs.berkeley.edu/~cs61c/resources/MIPS_Green_Sheet.pdf>MIPS Green Sheet</a> and the Opcodes chart courtesy of <a href=https://opencores.org/projects/plasma/opcodes>OpenCores</a>.
			</p>
			<h3>Register File Definition</h3>
			<div class="table-responsive">
				<table class="table table-bordered table-sm table-hover">
					<caption>MIPS register file definition</caption>
					<thead>
						<tr class="table-secondary">
							<th>Name</th>
							<th>Number</th>
							<th>Use</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>$zero</td>
							<td>0</td>
							<td>The Constant Value 0</td>
						</tr>
						<tr>
							<td>$at</td>
							<td>at</td>
							<td>Assembler Temporary</td>
						</tr>
						<tr>
							<td>$v0-$v1</td>
							<td>2-3</td>
							<td>Values for Function Results and Expression Evaluation</td>
						</tr>
						<tr>
							<td>$a0-$a3</td>
							<td>4-7</td>
							<td>Arguments</td>
						</tr>
						<tr>
							<td>$t0-$t7</td>
							<td>8-15</td>
							<td>Temporaries</td>
						</tr>
						<tr>
							<td>$s0-$s7</td>
							<td>16-23</td>
							<td>Saved Temporaries</td>
						</tr>
						<tr>
							<td>$t8-$t9</td>
							<td>24-25</td>
							<td>Temporaries</td>
						</tr>
						<tr>
							<td>$k0-$k1</td>
							<td>26-27</td>
							<td>Reserved for OS Kernel</td>
						</tr>
						<tr>
							<td>$gp</td>
							<td>28</td>
							<td>Global Pointer</td>
						</tr>
						<tr>
							<td>$sp</td>
							<td>29</td>
							<td>Stack Pointer</td>
						</tr>
						<tr>
							<td>$fp</td>
							<td>30</td>
							<td>Frame Pointer</td>
						</tr>
						<tr>
							<td>$ra</td>
							<td>31</td>
							<td>Return Address</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3>Core Instruction Set Definition</h3>
			<div class="table-responsive">
				<table class="table table-bordered table-sm table-hover">
						<thead>
							<tr>
								<th>Instruction</th>
								<th>Name</th>
								<th>Format</th>
								<th>Verilog Operation</th>
								<th colspan=6>Opcode bitfields</th>
							</tr>
						</thead>
						<thead>
							<tr class="table-secondary">
								<th colspan=10>
									Arithmetic Logic Unit
								</th>
							</tr>
						</thead>
						<tbody>
						<tr>
							<td>ADD rd, rs, rt</td>
							<td>Add</td>
							<td>R</td>
							<td>R[rd] = R[rs] + R[rt];<br>
								Ov = (R[rs](31)==R[rt](31))&amp;~(R[rt](31)==R[rd](31))
							</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100000</td>
						</tr>
						<tr>
							<td>ADDI rt, rs, imm</td>
							<td>Add Immediate</td>
							<td>I</td>
							<td>R[rt] = R[rs] + SignExtImm;<br>
								Ov = (R[rs](31)==R[rt](31))&amp;~(R[rt](31)==R[rd](31))
							</td>
							<td>001000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>ADDIU rt, rs, imm</td>
							<td>Add Immediate Unsigned</td>
							<td>I</td>
							<td>R[rt] = R[rs] + SignExtImm</td>
							<td>001001</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>ADDU rd, rs, rt</td>
							<td>Add Unsiged</td>
							<td>R</td>
							<td>R[rd] = R[rs] + R[rt]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</t	d>
							<td>00000</td>
							<td>100001</td>
						</tr>
						<tr>
							<td>AND rd, rs, rt</td>
							<td>And</td>
							<td>R</td>
							<td>R[rd] = R[rs] &amp; R[rt]</td>
							<td>000000	</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100100</td>
						</tr>
						<tr>
							<td>ANDI rt, rs, imm</td>
							<td>And Immediate</td>
							<td>I</td>
							<td>R[rt] = R[rs] &amp; ZeroExtImm</td>
							<td>001100</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>LUI rt, imm</td>
							<td>Load Upper Immediate</td>
							<td>I</td>
							<td>R[rt] = {imm,16’b0}</td>
							<td>001111</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>NOR rd, rs, rt</td>
							<td>Nor</td>
							<td>R</td>
							<td>R[rd] = ~(R[rs] | R[rt])</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100111</td>
						</tr>
						<tr>
							<td>OR rd, rs, rt</td>
							<td>Or</td>
							<td>R</td>
							<td>R[rd] = R[rs] | R[rt]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100101</td>
						</tr>
						<tr>
							<td>ORI rt, rs, imm</td>
							<td>Or Immediate</td>
							<td>I</td>
							<td>R[rt] = R[rs] | ZeroExtImm</td>
							<td>001101</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>SLT rd, rs, rt</td>
							<td>Set Less Than</td>
							<td>R</td>
							<td>R[rd] = $signed (R[rs] &lt; R[rt])?1:0</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>101010</td>
						</tr>
						<tr>
							<td>SLTI rt, rs, imm</td>
							<td>Set Less Than Immediate</td>
							<td>I</td>
							<td>R[rt] = $signed(R[rs] &lt; SignExtImm)?1:0</td>
							<td>001010</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>SLTIU rt, rs, imm</td>
							<td>Set Less Than Immediate Unsigned</td>
							<td>I</td>
							<td>R[rt] = (R[rs] &lt; SignExtImm)?1:0</td>
							<td>001011</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr>
							<td>SLTU rd, rs, rt</td>
							<td>Set Less Than Unsigned</td>
							<td>R</td>
							<td>R[rd] = (R[rs] &lt; R[rt])?1:0</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>101011</td>
						</tr>
						<tr>
							<td>SUB rd, rs, rt</td>
							<td>Subtract</td>
							<td>R</td>
							<td>R[rd] = $signed(R[rs] - R[rt]);<br>
								Ov = ~(R[rs](31)==R[rt](31))&amp;(R[rt](31)==R[rd](31))
							</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100010</td>
						</tr>
						<tr>
							<td>SUBU rd, rs, rt</td>
							<td>Subtract Unsigned</td>
							<td>R</td>
							<td>R[rd] = R[rs] - R[rt]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100011</td>
						</tr>
						<tr>
							<td>XOR rd, rs, rt</td>
							<td>Exclusive Or</td>
							<td>R</td>
							<td>R[rd] = R[rs] ^ R[rt]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>100110</td>
						</tr>
						<tr>
							<td>XORI rd, rs, imm</td>
							<td>Exclusive Or Immediate</td>
							<td>I</td>
							<td>R[rt] = R[rs] ^ ZeroExtImm</td>
							<td>001110</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>imm</td>
						</tr>
						<tr class="table-secondary">
							<th colspan=10 scope="row">Shifter</th>
						</tr>
						<tr>
							<td>SLL rd, rt, sa</td>
							<td>Shift Left Logical</td>
							<td>R</td>
							<td>R[rd] = R[rt] &lt;&lt; sa</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>sa</td>
							<td>000000</td>
						</tr>
						<tr>
							<td>SLLV rd, rt, rs</td>
							<td>Shift Left Logical Variable</td>
							<td>R</td>
							<td>R[rd] = R[rt] &lt;&lt; R[rs]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>000100</td>
						</tr>
						<tr>
							<td>SRA rd, rt, a</td>
							<td>Shift Right Arithmetic</td>
							<td>R</td>
							<td>R[rd] = R[rt] &lt;&lt;&lt; sa</td>
							<td>000000</td>
							<td>00000</td>
							<td>rt</td>
							<td >rd</td>
							<td>sa</td>
							<td>000011</td>
						</tr>
						<tr>
							<td>SRAV rd, rt, rs</td>
							<td>Shift Right Arithmetic Variable</td>
							<td>R</td>
							<td>R[rd] = R[rt] &lt;&lt;&lt; R[rs]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>000111</td>
						</tr>
						<tr>
							<td>SRL rd, rt, sa</td>
							<td>Shift Right Logical</td>
							<td>R</td>
							<td>R[rd] = R[rt] &gt;&gt; sa</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>sa</td>
							<td>000010</td>
						</tr>
						<tr>
							<td>SRLV rd, rt, rs</td>
							<td>Shift Right Logical Variable</td>
							<td>R</td>
							<td>R[rd] = R[rt] &gt;&gt; R[rs]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td >rd</td>
							<td>00000</td>
							<td>000110</td>
						</tr>
						<tr class="table-secondary">
							<th colspan=10>Multiply</th>
						</tr>
						<tr>
							<td>DIV rs, rt</td>
							<td>Divide</td>
							<td>R</td>
							<td>HI = $signed(rs) % $signed(rt); LO = $signed(rs) / $signed(rt)</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=2>0000000000</td>
							<td>011010</td>
						</tr>
						<tr>
							<td>DIVU rs, rt</td>
							<td>Divide Unsigned</td>
							<td>R</td>
							<td>HI = rs % rt; LO = rs / rt</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=2>0000000000</td>
							<td>011011</td>
						</tr>
						<tr>
							<td>MFHI rd</td>
							<td>Move From HI</td>
							<td>R</td>
							<td>R[rd] = HI</td>
							<td>000000</td>
							<td colspan=2>0000000000</td>
							<td >rd</td>
							<td>00000</td>
							<td>010000</td>
						</tr>
						<tr>
							<td>MFLO rd</td>
							<td>Move From LO</td>
							<td>R</td>
							<td>R[rd] = LO</td>
							<td>000000</td>
							<td colspan=2>0000000000</td>
							<td >rd</td>
							<td>00000</td>
							<td>010010</td>
						</tr>
						<tr>
							<td>MULT rs, rt</td>
							<td>Multiply</td>
							<td>R</td>
							<td>{HI,LO} = $signed({ {32{R[rs](31)}},R[rs]} * <br>
								{ {32{ R[rt](31) }},R[rt]});</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=2>0000000000</td>
							<td>011000</td>
						</tr>
						<tr>
							<td>MULTU rs, rt</td>
							<td>Multiply Unsigned</td>
							<td>R</td>
							<td>{HI,LO} = R[rs] * R[rt]</td>
							<td>000000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=2>0000000000</td>
							<td>011001</td>
						</tr>
						<tr class="table-secondary">
							<th colspan=10>Branch</th>
						</tr>
						<tr>
							<td>BEQ rs, rt, offset</td>
							<td>Branch On Equal</td>
							<td>I</td>
							<td>if(R[rs] == R[rt]) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000100</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BGEZ rs, offset</td>
							<td>Branch On &gt;= 0</td>
							<td>I</td>
							<td>if(R[rs] &gt;= 0) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000001</td>
							<td>rs</td>
							<td>00001</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BGEZAL rs, offset</td>
							<td>Branch On &gt;= 0 And Link</td>
							<td>I</td>
							<td>R[$ra] = pc; if(R[rs] &gt;= 0) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000001</td>
							<td>rs</td>
							<td>10001</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BGTZ rs, offset</td>
							<td>Branch On &gt; 0</td>
							<td>I</td>
							<td>if(R[rs] &gt; 0) pc += (offset &lt;&lt; 2) + 4 </td>
							<td>000111</td>
							<td>rs</td>
							<td>00000</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BLEZ rs, offset</td>
							<td>Branch On &lt;= 0</td>
							<td>I</td>
							<td>if(R[rs] &lt;= 0) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000110</td>
							<td>rs</td>
							<td>00000</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BLTZ rs, offset</td>
							<td>Branch On &lt; 0</td>
							<td>I</td>
							<td>if(R[rs] &lt; 0 ) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000001</td>
							<td>rs</td>
							<td>00000</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BLTZAL rs, offset</td>
							<td>Branch On &lt; 0 And Link</td>
							<td>I</td>
							<td>R[$ra] = pc; if(R[rs] &lt; 0) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000001</td>
							<td>rs</td>
							<td>10000</td>
							<td colspan=3>offset</td>
						</tr>
						<tr>
							<td>BNE rs, rt, offset</td>
							<td>Branch On Not Equal</td>
							<td>I</td>
							<td>if(R[rs] != R[rt]) pc += (offset &lt;&lt; 2) + 4</td>
							<td>000101</td>
							<td>rs</td>
							<td>rt
							</td>
							<td colspan=3>offset</td>
						</tr>
						<tr class="table-secondary">
							<th colspan=10>Jump</th>
						</tr>
						<tr>
							<td>J target</td>
							<td>Jump</td>
							<td>J</td>
							<td>pc = pc_upper | (target &lt;&lt; 2)</td>
							<td>000010</td>
							<td colspan=5>target</td>
						</tr>
						<tr>
							<td>JAL target</td>
							<td>Jump and Link</td>
							<td>J</td>
							<td>R[$ra] = pc; pc = (target &lt;&lt;2)</td>
							<td>000011</td>
							<td colspan=5>target</td>
						</tr>
						<tr>
							<td>JALR</td>
							<td>Jump and Link Register</td>
							<td>J</td>
							<td>R[rd] = pc; pc = R[rs]</td>
							<td>000000</td>
							<td>rs</td>
							<td>00000</td>
							<td>rd</td>
							<td>00000</td>
							<td>001001</td>
						</tr>
						<tr>
							<td>JR</td>
							<td>Jump Register</td>
							<td>J</td>
							<td>pc = R[rs]</td>
							<td>000000</td>
							<td>rs</td>
							<td colspan=3>000000000000000</td>
							<td>001000</td>
						</tr>
						<tr class="table-secondary">
							<th colspan=10 scope="row">Memory Access</th>
						</tr>
						<tr>
							<td>LB rt, offset(rs)</td>
							<td>Load Byte</td>
							<td>I</td>
							<td>R[rt] = SignExt(M[R[rs]+SignExtImm](7:0))</td>
							<td>100000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>LBU rt, offset(rs)</td>
							<td>Load Byte Unsigned</td>
							<td>I</td>
							<td>R[rt] = {24’b0, M[R[rs]+SignExtImm](7:0)}</td>
							<td>100100</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>LH rt, offset(rs)</td>
							<td>Load Halfword</td>
							<td>I</td>
							<td>R[rt] = SignExt(M[R[rs]+SignExtImm](15:0))</td>
							<td>100001</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>LHU rt, offset(rs)</td>
							<td>Load Halfword Unsiged</td>
							<td>I</td>
							<td>R[rt] = {16’b0, M[R[rs]+SignExtImm](15:0)}</td>
							<td>100101</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>LW rt, offset(rs)</td>
							<td>Load Word</td>
							<td>I</td>
							<td>R[rt] = M[R[rs]+SignExtImm]</td>
							<td>100011</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>SB rt, offset(rs)</td>
							<td>Store Byte</td>
							<td>I</td>
							<td>M[R[rs]+SignExtImm](7:0) = R[rt](7:0)</td>
							<td>101000</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>SH rt,offset(rs)</td>
							<td>Store Halfword</td>
							<td>I</td>
							<td>M[R[rs]+SignExtImm](15:0) = R[rt](15:0)</td>
							<td>101001</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr>
							<td>SW rt,offset(rs)</td>
							<td>Store Word</td>
							<td>I</td>
							<td>M[R[rs]+SignExtImm] = R[rt]</td>
							<td>101011</td>
							<td>rs</td>
							<td>rt</td>
							<td colspan=3>offset/imm</td>
						</tr>
						<tr class="table-info">
							<td colspan=10>SignExtImm = {16{imm[15],imm}<br>
								ZeroExtImm = {16{1’b0},imm}<br>
								pc_upper = pc[31:28]<br>
								Ov = Overflow Flag, Active High
							</td>
						</tr>
					</table>
			</div>
			<div>
				<h3>Other References</h3>
				<p>The following resources supported our overall implementation.</p>
				<ul>
					<li><b>Omran, Safaa S. and Hadeel S. Mahmood. <em><a href=https://www.researchgate.net/publication/301694967_HARDWARE_MODELLING_OF_A_32-BIT_SINGLE_CYCLE_RISC_PROCESSOR_USING_VHDL>Hardware Modeling of a 32-bit, Single Cycle RISC Processor Using VHDL</a></em>. ICIT 2013 The 6th International Conference on Information Technology. May 2013.</b> The block diagram titled "The complete datapath control scheme of MIPS" was a helpful resource in mapping out additional operations in our CPU.
					<li><em>Arithmetic.</em> Duke University. 2011. This was an introductory lecture to floating-point arithmetic.
				</ul>
			</div>
    </div>
  </main>
  <footer>
    <div class="fixed-bottom">
      <p class="text-center text-white" >© Michael Remley and Megan Ku. Made with Bootstrap</p>
    </div>
  </footer>
</body>

</html>
