<html>

<head>
	<title>Home</title>
	<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


</head>

<body class="bg-secondary">
	<header>
		<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
		  <a class="navbar-brand" href="./index.html">Kurem</a>
		  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
		    <span class="navbar-toggler-icon"></span>
		  </button>

		  <div class="collapse navbar-collapse" id="navbarSupportedContent">
		    <ul class="navbar-nav mr-auto">
		      <li class="nav-item" id="nav-item-home">
		        <a class="nav-link" href="./index.html">Home</a>
		      </li>
		      <li class="nav-item">
		        <a class="nav-link" href="./reference.html" id="nav-item-documentation">Reference</a>
		      </li>

					<li class="nav-item">
		        <a class="nav-link" href="./about.html" id="nav-item-about">About Us</a>
		      </li>
		    </ul>

		  </div>
		</nav>
	</header>
	<main>
		<div class="container bg-light" id="main-content">
			<div class="border-bottom">
				<h2>Introduction</h2>
				<p>[catchy sentence for techy people]</p>
				<p>[a paragraph or two about why a complete processor is dope]</o>
				<p>[behavioral, not structural]</p>
			</div>
			<div class="border-bottom">
				<h2>Goal: The Complete MIPS Instruction Set</h2>
				<p> To implement a complete MIPS processor, we needed a complete definition of the processor’s behavior.</p>
			</div>
			<div class="border-bottom">
				<h2>Part 1: Base MIPS Processor</h2>
					<h3>Testbench ("test_cpu.v")</h3>
					<p>The testbench for this MIPS cpu initializes the processor with compiled data/memory and a reset pulse, then provides a clock until program exit.</p>
					<div class="mx-auto">
						<figure class="figure">
						  <img src="./img/baseMIPS.png" class="figure-img img-fluid rounded" alt="...">
						  <figcaption class="figure-caption">The base MIPS processor.</figcaption>
						</figure>
					</div>
					<p>The base MIPS processor must perform the basic functions of a single-cycle CPU: instruction fetch, instruction decode, operand fetch, execute, result store. In our Verilog implementation, instruction fetch logic is in module “fetch.v”; data memory and instruction memory are a single module, “memory.v”; instruction decode logic is in “decode.v”; and the arithmetic and logic of the execute step is in “alu.v”. These modules are connected to each other in “cpu.v”.</p>
					<h3>Top-Level Structure (“cpu.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>Clock</li>
						<li>Reset</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>SYSCALL print outputs</li>
					</ul>
					<strong>Specification</strong>
					<p>The components of the MIPS processor are all declared and connected in this module. The immediate extend type, alu source, and register source multiplexers (MUXes) are here. The SYSCALL functions are executed by this module if a SYSCALL instruction is detected in the instruction independent of the decode module.</p>
					<h3>IF: Instruction Fetch (“fetch.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>Clock</li>
						<li>Reset: If asserted, set pc_next = 0</li>
						<li>pc_src: An value from 0-3 defining the source of the next value for the program counter (pc).</li>
						<li>isZero: A binary value which is asserted if the arithmetic logic unit has calculated a zero-valued result.</li>
						<li>branch_ctrl: A binary value which controls whether to perform a branch or not in conjunction with isZero, given pc_src indicates a branch instruction is underway.</li>
						<li>reg_addr: A 32-bit value from a register used as the complete next program counter value in jump register instructions.</li>
						<li>jump_addr: A 26-bit value to which the program counter is set in non-register jump instructions.</li>
						<li>imm_addr: A 16-bit value that functions as an offset from the current program counter in branch instructions.</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>pc_next: The value of the program counter on the next instruction. Instruction is retrieved from instruction memory in the memory module.</li>
					</ul>
					<strong>Specification</strong>
					<p>The fetch module produces the value of the program counter according to the type of instruction and conditional information in the case of branch instructions. The program counter (pc) is word-aligned, so the lower 2 bits are always zero. If pc_src == 0 or is invalid, the behavior is to increment the program counter to the next instruction by adding 4. If pc_src == 1, the pc_next is set to the jump address, jump_addr << 2. If pc_src == 2, the pc is incremented by 4 then conditionally incremented by imm_addr if the branch condition is met. Branch behavior is described in more detail later. Finally, if pc_src == 3, the program counter is set to a value from the register file reg_addr.</p>
					<h3>MEM: Memory (“memory.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>Clock</li>
						<li>Reset: If asserted, set pc_next = 0</li>
						<li>PC: Program counter (instruction address)</li>
						<li>mem_cmd:  Either a no-operation (do nothing), read, or write. The module will not read/write memory unless this is set.</li>
						<li>data_in: Data to write to a register.</li>
						<li>data_addr: The address to which to write or from which to read</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>instruction: The 32-bit instruction to be decoded</li>
						<li>data_out: The value read from data_addr, if any.</li>
					</ul>
					<strong>Specification</strong>
					<p>The memory module has two main tasks: read the instruction from memory and perform program memory operations. The module will always produce instruction based on the value of the program counter, but memory operations only occur if mem_cmd is not a no-operation. The memory array is implemented as a 4096 element array of 32-bit words, so the lower 2 bits of the data_addr are discarded. The memory range is limited such that the upper 17 bits of both data_addr and the program counter must be zero, otherwise an error is thrown and execution stops.
					</p>
					<h3>DEC: Intruction Decode (“decode.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>Instruction</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>wa: Write register address </li>
						<li>ra1: Read register address 1</li>
						<li>ra2: Read register address 2</li>
						<li>reg_wen: Register write enable</li>
						<li>imm_ext: Type of extension (Zero or Sign) to perform on the immediate.</li>
						<li>imm: Immediate value.</li>
						<li>addr: Immediate Address for jump and branch instructions.</li>
						<li>alu_op: Arithmetic logic unit operation to perform, usually the function code.</li>
						<li>pc_src: Source for the program counter.</li>
						<li>mem_cmd: No-operation, read, or write memory.</li>
						<li>alu_src: Selects alu operand B from register data 2, immediate, or shift amount (sa).</li>
						<li>reg_src: Selects register write data from the alu, memory, program counter + 4, HI, or LO.</li>
						<li>branch_ctrl: If asserted, use invert isZero to get branch condition. </li>
					</ul>
					<strong>Specification</strong>
					<p>The decode module sets all the control wires according to the behavior specification in Table 2. It is implemented as a set of nested switch statements and would probably be implemented as a lookup table. Not all outputs must have a definite value for all operations.
					</p>
					<h3>OF: Operand Fetch (“regfile.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>Clock</li>
						<li>Reset: Set all register values to 0, set R[$sp] = 0x3ffc</li>
						<li>wren: Enable register writes</li>
						<li>wa: Register address to write</li>
						<li>wd: Register data to write</li>
						<li>ra1: Read address 1</li>
						<li>ra2: Read address 2</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>rd1: Data read from ra1 </li>
						<li>rd2: Data read from ra2</li>
					</ul>
					<strong>Specification</strong>
					<p>The register file produces the operands for the cycle and performs any write operations if wren is asserted. Table 1 describes the registers in more detail. The stack pointer, $sp, resets to 0x3ffc and the stack grows downward.
					</p>
					<h3>EX: Execute (“alu.v”)</h3>
					<strong>Inputs</strong>
					<ul>
						<li>alu_op: Which operation to perform, usually a function code from the instruction.</li>
						<li>A: Operand A, always rd1 from the register file module.</li>
						<li>B: Operand B, either rd2, zero/sign extended immediate, or shift amount.</li>
					</ul>
					<strong>Outputs</strong>
					<ul>
						<li>R: Result of alu_op on the operands.</li>
						<li>HI,LO: Result of multiplication and division operations.</li>
						<li>Overflow: Asserted if an overflow occurred, currently halts execution if asserted.</li>
						<li>isZero: Asserted if R == 0.</li>
					</ul>
					<strong>Specification</strong>
					<p>The arithmetic logic unit (ALU) takes operands as inputs and produces a result. The result is used to evaluate branch conditionals or is stored to memory/register. Signed addition and subtraction can cause overflow interrupts, in which case the processor halts.
					</p>
				</div>
			<div class="border-bottom">
				<h2>Part 2: Branch Instructions</h2>
				<p>
					We first implemented the remaining branch instructions: BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL. All the branch instructions evaluate a conditional statement and branch when that conditional is met. Our arithmetic logic unit generates the isZero flag whenever the operation causes the result to be 0, and we invert this flag for certain instructions to branch if the condition is met or not. For BNE and BEQ, the arithmetic operation that causes the isZero flag to toggle on the right conditions is Subtraction. For BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL, the right operation is Set Less Than and a certain order for the operands. An additional flag, BranchCtrl, is asserted to invert the isZero flag via an XOR gate to generate the final doBranch flag for all “not equal” instructions (BNE, BGTZ, BLTZ, BLTZAL). BranchCtrl is not asserted for the “equal” instructions (BEQ, BGEZ, BGEZAL, BLEZ) to leave isZero as is. The decode module assigns the branch_ctrl, alu_op, and register address wires wa, ra1, ra2 to execute this behavior. For BGEZAL and BLTAL, the decode also asserts register file to write the program counter to R[$ra] via register write enable reg_wen and register file source reg_src.
				</p>
				<table class="table table-bordered table-sm table-hover">
					<caption>Branch operation truth table. Note: BGEZAL and BLTZAL behave like BGEZ and BLTZ but add the operation R[$ra]=pc;</caption>
					<thead>
						<tr class="table-secondary">
							<th>Instruction</th>
							<th>ALU operation</th>
							<th>branch_ctrl</th>
							<th>isZero</th>
							<th>doBranch (isZero XOR branch_ctrl)</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>BEQ</td>
							<td>R[rs] - R[rt]</td>
							<td>0</td>
							<td>0</td>
							<td>No</td>
						</tr>
						<tr>
							<td>BEQ</td>
							<td>R[rs] - R[rt]</td>
							<td>0</td>
							<td>1</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BNE</td>
							<td>R[rs] - R[rt]</td>
							<td>1</td>
							<td>0</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BNE</td>
							<td>R[rs] - R[rt]</td>
							<td>1</td>
							<td>1</td>
							<td>No</td>
						</tr>
						<tr>
							<td>BGEZ</td>
							<td>R[rs] < R[$zero]</td>
							<td>0</td>
							<td>0</td>
							<td>No</td>
						</tr>
						<tr>
							<td>BGEZ</td>
							<td>R[rs] < R[$zero]</td>
							<td>0</td>
							<td>1</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BGTZ</td>
							<td>R[$zero] < R[rs]</td>
							<td>1</td>
							<td>0</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BGTZ</td>
							<td>R[$zero] < R[rs]</td>
							<td>1</td>
							<td>1</td>
							<td>No</td>
						</tr>
						<tr>
							<td>BLEZ</td>
							<td>R[$zero] < R[rs]</td>
							<td>0</td>
							<td>0</td>
							<td>No</td>
						</tr>
						<tr>
							<td>BLEZ</td>
							<td>R[$zero] < R[rs]</td>
							<td>0</td>
							<td>1</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BLTZ</td>
							<td>R[rs] < R[$zero]</td>
							<td>1</td>
							<td>0</td>
							<td>Yes</td>
						</tr>
						<tr>
							<td>BLTZ</td>
							<td>R[rs] < R[$zero]</td>
							<td>1</td>
							<td>1</td>
							<td>No</td>
						</tr>
					</tbody>
				</table>
				<p>
					In “decode.v”, the decoder differentiates BGEZ, BGEZAL, BLTZ, and BLTZAL by the value in the field marked rt because they share the opcode 0x1. BEQ, BLEZ, BGTZ, and BNE are differentiated by their unique opcodes. The decoder assigns all control wires according to the behavior outlined in Table 1 and Table 2. In “alu.v”, no changes were needed since SLT, SUB, and isZero are used in their normal ways.
				</p>
				<p>
					In “fetch.v”, all branch instructions start by incrementing the program counter by 4. If doBranch is true, indicating the branch should be followed, then add offset << 2 to the program counter. Otherwise, do nothing (regular program counter increment). Some pseudocode outlining this behavior follows:
				</p>
				<pre><code>
					pc_next = pc_next + 4
					if (branch_ctrl ^ isZero)
					pc_next = pc_next + (offset << 2)
				</code></pre>
				<p>
					Our Verilog implementation of the above pseudocode is in part of the `PC_SRC_BRCH case in “fetch.v”.
				</p>
				<figure class="figure">
					<img src="./img/branchMIPS.png" class="figure-img img-fluid rounded" alt="...">
					<figcaption class="figure-caption">The MIPS processor with advanced branch capability.</figcaption>
				</figure>
				<ul>
					<li>branch.asm tests BEQ and BNE by converging an initial value to a target value by half the difference each loop.</li>
					<li>branchAL.asm tests BLTAL and BGEZAL by printing four strings in order and not printing a fifth string.</li>
					<li>branchEZ.asm tests BGEZ and GLEZ by printing four strings in order and not printing a fifth string.</li>
					<li>branchTZ.asm test BGTZ and BLTZ by printing four string in order and not printing a fifth string.</li>
				</ul>
				<p class="list-group-item bg-warning">
					While testing branch instructions, we learned that the MARS compiler, our reference for correct assembly execution, was set to use delayed branch execution. Delayed branch execution occurs in some processors and results in the instruction after any branch instruction being executed no matter if the branch is followed or not. Our Verilog processor does not behave this way, so we disabled delayed branch execution.
				</p>
			</div>
			<div class="border-bottom">
				<h3>Part 3: Integer Multiplication/Division</h3>
				<p>
					Multiplication and division differ from addition and subtraction because their results are stored in two special 32-bit registers called HI and LO, as opposed to a single 32-bit output. For multiplication, the least-significant 32 bits are stored in LO and the most-significant 32 bits are stored in HI. In division, LO stores the quotient, while HI stores the remainder. On top of implementing the HI and LO registers, we also had to implement MFHI (move from HI) and MFLO (move from LO) to retrieve the output of these operations. When we first implemented signed multiplication, or MULT, we found that the result was not producing the correct output, so we had to manually sign-extended both the multiplicand and the multiplier in Verilog to resolve the issue. The Verilog code that performs signed multiplication and register values A and B properly looks a little odd:
				</p>
				<pre><code>{HI,LO} = $signed({{32{A_sign}}, A} * {{32{B_sign}}, B});</code></pre>
				<p>But it works!</p>
				<figure class="figure">
					<img src="./img/multMIPS.png" class="figure-img img-fluid rounded" alt="...">
					<figcaption class="figure-caption">Block diagram for implementation of multiplication and division. Note that DIV/MULT represents whether the ALU operation is division or multiplication. Our CPU supports both signed and unsigned multiplication and division.</figcaption>
				</figure>
			</div>
		</div>
	</main>
	<footer>
		<div class="fixed-bottom">
			<p class="text-center text-white" >© Michael Remley and Megan Ku. Made with Bootstrap</p>
		</div>
	</footer>
</body>

</html>
